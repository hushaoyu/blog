{"meta":{"title":"漫漫前端路","subtitle":"业精于勤，荒于嬉","description":"简单的工作，简单的生活","author":"跳过这片海","url":"https://hushaoyu.github.io","root":"/"},"pages":[{"title":"404","date":"2022-01-07T02:07:20.000Z","updated":"2022-01-07T02:09:03.921Z","comments":false,"path":"/404.html","permalink":"https://hushaoyu.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-06T08:49:28.000Z","updated":"2022-01-06T09:45:21.681Z","comments":false,"path":"categories/index.html","permalink":"https://hushaoyu.github.io/categories/index.html","excerpt":"","text":""},{"title":"intro","date":"2022-01-06T09:02:29.000Z","updated":"2022-01-06T09:45:21.676Z","comments":false,"path":"index.html","permalink":"https://hushaoyu.github.io/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-06T08:50:17.000Z","updated":"2022-01-07T06:26:44.916Z","comments":false,"path":"tags/index.html","permalink":"https://hushaoyu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TypeScript - React组件中的类型注解","slug":"TypeScript-React组件中的类型注解","date":"2022-01-26T07:02:32.000Z","updated":"2022-01-26T09:11:28.593Z","comments":true,"path":"2022/01/26/TypeScript-React组件中的类型注解/","link":"","permalink":"https://hushaoyu.github.io/2022/01/26/TypeScript-React%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/","excerpt":"React 中可能用到的 TypeScript 类型注解 code 123456789101112131415161718192021222324252627282930313233343536373839type AppProps = &#123; message: string; count: number; disabled: boolean; /** array of a type! */ names: string[]; /** string literals to specify exact string values, with a union type to join them together */ status: &quot;waiting&quot; | &quot;success&quot;; /** any object as long as you dont use its properties (NOT COMMON but useful as placeholder) */ obj: object; obj2: &#123;&#125;; // almost the same as `object`, exactly the same as `Object` /** an object with any number of properties (PREFERRED) */ obj3: &#123; id: string; title: string; &#125;; /** array of objects! (common) */ objArr: &#123; id: string; title: string; &#125;[]; /** a dict object with any number of properties of the same type */ dict1: &#123; [key: string]: MyTypeHere; &#125;; dict2: Record&lt;string, MyTypeHere&gt;; // equivalent to dict1 /** any function as long as you don&#x27;t invoke it (not recommended) */ onSomething: Function; /** function that doesn&#x27;t take or return anything (VERY COMMON) */ onClick: () =&gt; void; /** function with named prop (VERY COMMON) */ onChange: (id: number) =&gt; void; /** function type syntax that takes an event (VERY COMMON) */ onChange: (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void; /** alternative function type syntax that takes an event (VERY COMMON) */ onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void; /** an optional prop (VERY COMMON!) */ optional?: OptionalType;&#125;;","text":"React 中可能用到的 TypeScript 类型注解 code 123456789101112131415161718192021222324252627282930313233343536373839type AppProps = &#123; message: string; count: number; disabled: boolean; /** array of a type! */ names: string[]; /** string literals to specify exact string values, with a union type to join them together */ status: &quot;waiting&quot; | &quot;success&quot;; /** any object as long as you dont use its properties (NOT COMMON but useful as placeholder) */ obj: object; obj2: &#123;&#125;; // almost the same as `object`, exactly the same as `Object` /** an object with any number of properties (PREFERRED) */ obj3: &#123; id: string; title: string; &#125;; /** array of objects! (common) */ objArr: &#123; id: string; title: string; &#125;[]; /** a dict object with any number of properties of the same type */ dict1: &#123; [key: string]: MyTypeHere; &#125;; dict2: Record&lt;string, MyTypeHere&gt;; // equivalent to dict1 /** any function as long as you don&#x27;t invoke it (not recommended) */ onSomething: Function; /** function that doesn&#x27;t take or return anything (VERY COMMON) */ onClick: () =&gt; void; /** function with named prop (VERY COMMON) */ onChange: (id: number) =&gt; void; /** function type syntax that takes an event (VERY COMMON) */ onChange: (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void; /** alternative function type syntax that takes an event (VERY COMMON) */ onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void; /** an optional prop (VERY COMMON!) */ optional?: OptionalType;&#125;; 在对 Props 和 State 进行类型注解时，使用 type 还是 interface? 建议： 总是使用 interface 来为公共库或者第三方环境进行类型定义，因为如果后续发现缺少定义，使用者可以通过声明合并来扩展 interface 考虑使用 type 来为 React 组件的 Props 和 State 进行类型定义，这样可以给它们增加更多的限制和提高一致性。 参考资料 Interface vs Type alias in TypeScript 2.7 Differences Between Type Aliases and Interfaces 类型定义对于使用联合类型更有帮助，如 type MyType = TypeA | TypeB，而 interface 更适合声明字典形状，然后实现或扩展它们 type 和 interface 对比 对比项 type interface Can describe functions ✅ ✅ Can describe constructors ✅ ✅ Can describe tuples ✅ ✅ Interfaces can extend it ⚠️ ✅ Classes can extend it 🚫 ✅ Classes can implement it (implements) ⚠️ ✅ Can intersect another one of its kind ✅ ⚠️ Can create a union with another one of its kind ✅ 🚫 Can be used to create mapped types ✅ 🚫 Can be mapped over with mapped types ✅ ✅ Expands in error messages and logs ✅ 🚫 Can be augmented 🚫 ✅ Can be recursive ⚠️ ✅ type 和 interface 的区别 如果在 type 类型定义中使用了联合运算符，则不能在具有类型别名的类上使用 interface123456789101112131415161718192021type dog = &#123; color: string&#125;type bean = &#123; fly: boolean&#125;interface cat &#123; sex: string&#125;type animal1 = dog &amp; cat;class cat1 implements animal1 &#123; color = &#x27;red&#x27;; sex = &#x27;1&#x27;;&#125;type animal2 = (dog | bean) &amp; cat;class cat2 implements animal2 &#123; color = &#x27;red&#x27;; sex = &#x27;1&#x27;; fly= true;&#125;// A class can only implement an object type or intersection of object types with statically known members.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://hushaoyu.github.io/categories/TypeScript/"},{"name":"React Props","slug":"TypeScript/React-Props","permalink":"https://hushaoyu.github.io/categories/TypeScript/React-Props/"}],"tags":[{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://hushaoyu.github.io/tags/TypeScript/"}]},{"title":"JavaScript - 开发技巧","slug":"JavaScript-开发技巧","date":"2022-01-26T02:50:22.000Z","updated":"2022-01-26T02:50:22.269Z","comments":true,"path":"2022/01/26/JavaScript-开发技巧/","link":"","permalink":"https://hushaoyu.github.io/2022/01/26/JavaScript-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"工具合集","slug":"工具合集","date":"2022-01-25T06:39:29.000Z","updated":"2022-01-25T07:34:51.223Z","comments":true,"path":"2022/01/25/工具合集/","link":"","permalink":"https://hushaoyu.github.io/2022/01/25/%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/","excerpt":"文件处理 链接 描述 跳转 图片文字处理 跳转 在线PS 跳转 图片格式转换 跳转 图片压缩 跳转 文件转换器 跳转 PDF转换器 跳转 SVG转换透明背景","text":"文件处理 链接 描述 跳转 图片文字处理 跳转 在线PS 跳转 图片格式转换 跳转 图片压缩 跳转 文件转换器 跳转 PDF转换器 跳转 SVG转换透明背景 资源获取 链接 描述 跳转 PPT模板 跳转 文档模板 开发工具 链接 描述 跳转 进制转换 跳转 RGB颜色查询对照表 跳转 生成随机密码 跳转 CRON表达式生成 跳转 JavaScript编辑器 跳转 codesandbox 在线框架编程 跳转 css属性兼容性查看 跳转 渐变色生成 跳转 TypeScript编辑器 设计 链接 描述 跳转 Logo设计 跳转 设计 跳转 艺术字生成 其他| 链接 | 描述 || 跳转 | 二维码解码 || 跳转 | OCR || 跳转 | SSL安装校验 || 跳转 | 网站证书文件处理 |","categories":[{"name":"工具","slug":"工具","permalink":"https://hushaoyu.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hushaoyu.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Typescript - 基础","slug":"Typescript-基础","date":"2022-01-25T06:34:15.000Z","updated":"2022-01-26T06:57:06.167Z","comments":true,"path":"2022/01/25/Typescript-基础/","link":"","permalink":"https://hushaoyu.github.io/2022/01/25/Typescript-%E5%9F%BA%E7%A1%80/","excerpt":"什么是 TypeScript TypeScript 是 JavaScript 的一个超集。","text":"什么是 TypeScript TypeScript 是 JavaScript 的一个超集。 学习文档 TypeScript with React Link 进度 Link 类型注解 在变量名后面接着一个冒号，冒号后面跟着类型表达式，表达式描述了这个变量可以具有的值。1let x: number; 上述表达式，定义了一个数字类型的变量 x。你也许会有疑问，x 在定义时，没有指定具体的值，按理值应该是 undefined，这就与定义的 number 类型不一样了。TypeScript 针对这种变量定义未赋值的情况，是不允许程序后续读取的。123let a: number;alert(a);// Variable &#x27;a&#x27; is used before being assigned. 类型表达式 针对 JavaScript 设定的类型可选表达式 undefined、null boolean、number、string symbol object TypeScript 特有的 Array any ... 除了上述的单一类型，有很多方法可以将这些类型组合成新的联合类型，如使用交并集符号 (U)、(∩)。更多 类型别名 可以针对某一个类型，使用 type 关键字创建别名12type Age = number;let age: Age = 2; 类型推断 并不是在任何时候都需要显示地指定定义变量的类型，TypeScript 会依照类型推断的规则，推断出变量的类型 如下代码，根据类型推断规则，变量 a 被推断为 number 类型，如果后续更改为其他类型，将报错12345let a = 1;console.log(typeof a);// &quot;number&quot;a = &#x27;a&#x27;;// Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;. TypeScript 中的类型 &ensp;&ensp;JavaScript 中有8中数据类型，分别是 Undefined、Null、Boolean、String、Number、BigInt、Symbol、Object。所有这些数据的类型是动态的，可以再程序运行时修改数据的类型。 布尔值：使用 boolean 定义的值 定义1let isDone: boolean = false; 当修改成其他类型的值时，会报错123let isDone: boolean = false;isDone = 3;// .code.tio.ts(2,1): error TS2322: Type &#x27;3&#x27; is not assignable to type &#x27;boolean&#x27;. 通过构造函数 Boolean 创建的实例对象不是 boolean 类型的值，而是一个 Boolean 对象，因此不能通过 Boolean 创建实例对象赋值给 boolean 定义的变量1234let a: boolean = false;a = new Boolean(1);// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.// &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object. Prefer using &#x27;boolean&#x27; when possible. 数值型：使用 number 定义的值 定义1let num: number = 4; 同样的，无法通过构造函数 Number 创建的实例对象赋值给 number 类型的变量 特别的，可以将十六进制、二进制、八进制、NaN 及 Infinity【表示无穷大的数值，超出 1.7976931348623157E+103088 的数值】赋值给 number 类型的变量123456let num: number = 4;num = 0xf00d;num = 0b1010;num = 0o744;num = NaN;num = Infinity; 字符串类型：使用 string 定义的值 定义12let str: string = &#x27;2&#x27;;let stri = `String is $&#123;str&#125;`; 数组 JavaScript 数组在 TypeScript 中有两种表现形式，List 和 Tuple List：集合捏所有元素的类型相同，但是集合的长度不固定 定义 两种定义方式12let arr1: number[] = [];let arr2: Array&lt;number&gt; = []; Tuple：元组内元素的类型不一定都一样，但是元组的长度是固定的 定义12let point: [number, number] = [7, 5];let points: [string, number] = [&#x27;a&#x27;, 1]; 函数 简写方式1(num: number) =&gt; string 完整写法12const func: (num: number) =&gt; string =(num: number) =&gt; String(num); 复杂的例子1234567891011121314function stringify123(callback: (num: number) =&gt; string) &#123; return callback(123);&#125;stringify123();// Expected 1 arguments, but got 0.stringify123(123);// Argument of type &#x27;number&#x27; is not assignable to parameter of type &#x27;(num: number) =&gt; string&#x27;.stringify123(&#x27;123&#x27;);// Argument of type &#x27;number&#x27; is not assignable to parameter of type &#x27;(num: number) =&gt; string&#x27;.stringify123(Number);// Argument of type &#x27;NumberConstructor&#x27; is not assignable to parameter of type &#x27;(num: number) =&gt; string&#x27;.// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.stringify123(String);stringify123(() =&gt; &#x27;123&#x27;); 上述 stringify123 函数，返回的是 string 类型，我们没有显示地指定函数的返回类型，大多数情况下，推荐对所有的参数都显示地注明数据类型123function stringify123(callback: (num: number) =&gt; string): string &#123; return callback(123);&#125; 特殊的类型注解：void &ensp;&ensp;void 是函数的一种特殊结果类型：它告诉 TypeScript 函数总是返回 undefined（显式或隐式） 1234function f1(): void &#123; return undefined &#125; // 显示function f2(): void &#123; &#125; // 隐式function f3(): void &#123; return &#x27;abc&#x27; &#125;// Type &#x27;string&#x27; is not assignable to type &#x27;void&#x27;. 可选的参数：标识符 ?后面的参数表示是可选参数1234567891011function stringify123(callback?: (num: number) =&gt; string) &#123; if (callback === undefined) &#123; callback = String; &#125; return callback(123);&#125;stringify123();stringify123(&#x27;234&#x27;);// Argument of type &#x27;&quot;234&quot;&#x27; is not assignable to parameter of type &#x27;((num: number) =&gt; string) | undefined&#x27;.stringify123(String); 参数默认值：配置了参数默认值，这种情况下，参数的类型注解是可选的，因为 TypeScript 会根据参数默认值推断出参数的类型1234567function createPoint(x=0, y=0): [number, number] &#123; return [x, y];&#125;createPoint();createPoint(1,2);createPoint(&#x27;1&#x27;, 2);// Argument of type &#x27;&quot;&quot;&#x27; is not assignable to parameter of type &#x27;number | undefined&#x27;. 剩余参数：剩余参数必须是数组类型12345678function joinNumbers(a: string, ...nums: number[]): string &#123; return nums.join(&#x27;-&#x27;);&#125;joinNumbers(1, 2, 3);// Argument of type &#x27;number&#x27; is not assignable to parameter of type &#x27;string&#x27;.joinNumbers(&#x27;1&#x27;,2,&#x27;a&#x27;);// Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.joinNumbers(&#x27;1&#x27;,2,3); 联合类型 在 JavaScript 中，变量的类型是动态的，一个变量的类型，在程序的运行过程中，可能处于不同的类型，为了描述这些变量，在 TypeScript 中，可以使用联合类型，联合类型使用 | 分割123456789101112131415function getScore(numberOrString: number|string): number &#123; if (typeof numberOrString === &#x27;string&#x27; &amp;&amp; /^\\*&#123;1,5&#125;$/.test(numberOrString)) &#123; return numberOrString.length; &#125; else if (typeof numberOrString === &#x27;number&#x27; &amp;&amp; numberOrString &gt;= 1 &amp;&amp; numberOrString &lt;= 5) &#123; return numberOrString &#125; else &#123; throw new Error(&#x27;Illegal value: &#x27; + JSON.stringify(numberOrString)); &#125;&#125;getScore(1);getScore(&#x27;a&#x27;);getScore(true);// Argument of type &#x27;boolean&#x27; is not assignable to parameter of type &#x27;string | number&#x27;. 默认情况下，除非显示地指定，否则联合类型是不包括 undefined 和 null 的。1234getScore(undefined);// Argument of type &#x27;undefined&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.getScore(null);// Argument of type &#x27;null&#x27; is not assignable to parameter of type &#x27;string | number&#x27;. 比较：可选、默认值、联合类型：undefined | null 如果参数是可选的，那参数可以被省略，省略时值默认为 undefined，不省略，只能传给定类型的值12345function f1(x?: number) &#123; console.log(x) &#125;;f1(); // undefinedf1(1); // 1f1(&#x27;a&#x27;);// Argument of type &#x27;&quot;a&quot;&#x27; is not assignable to parameter of type &#x27;number | undefined&#x27;. 如果参数是有默认值的，参数的值也是可选的，省略时，参数的值为给定的默认值。不省略时，除了传给定类型的值外，还可以指定为 undefined12345678function f1(x = 1) &#123; console.log(x) &#125;;f1(); // 1f1(1); // 1f1(undefined); // undefinedf1(null);// Argument of type &#x27;null&#x27; is not assignable to parameter of type &#x27;number | undefined&#x27;.f1(&#x27;a&#x27;);// Argument of type &#x27;&quot;a&quot;&#x27; is not assignable to parameter of type &#x27;number | undefined&#x27;. 如果是联合类型：undefined | null，那参数是不能省略的12345function f1(x: number | undefined) &#123; console.log(x) &#125;;f1();// Expected 1 arguments, but got 0.f1(1);f1(undefined); 对象类型","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://hushaoyu.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://hushaoyu.github.io/tags/TypeScript/"}]},{"title":"ThreeJS - 知识体系","slug":"ThreeJS-知识体系","date":"2022-01-24T08:25:59.000Z","updated":"2022-01-24T08:51:26.252Z","comments":true,"path":"2022/01/24/ThreeJS-知识体系/","link":"","permalink":"https://hushaoyu.github.io/2022/01/24/ThreeJS-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"基于物理的渲染","categories":[{"name":"ThreeJs","slug":"ThreeJs","permalink":"https://hushaoyu.github.io/categories/ThreeJs/"}],"tags":[{"name":"ThreeJs","slug":"ThreeJs","permalink":"https://hushaoyu.github.io/tags/ThreeJs/"}]},{"title":"Hexo - 持续改进","slug":"Hexo-持续改进","date":"2022-01-24T08:04:40.000Z","updated":"2022-01-26T09:17:19.745Z","comments":true,"path":"2022/01/24/Hexo-持续改进/","link":"","permalink":"https://hushaoyu.github.io/2022/01/24/Hexo-%E6%8C%81%E7%BB%AD%E6%94%B9%E8%BF%9B/","excerpt":"表格样式改进 在 themes/next/source/css 目录下新建目录 _custom，并新建表格样式文件 table.css，样式内容如下：","text":"表格样式改进 在 themes/next/source/css 目录下新建目录 _custom，并新建表格样式文件 table.css，样式内容如下： CSS 12345678910111213141516171819202122232425262728293031323334table &#123; width: 100%; /*表格宽度*/ max-width: 65em; /*表格最大宽度，避免表格过宽*/ border: 1px solid #dedede; /*表格外边框设置*/ margin: 15px auto; /*外边距*/ border-collapse: collapse; /*使用单一线条的边框*/ empty-cells: show; /*单元格无内容依旧绘制边框*/ border-radius: 4px;&#125;table th,table td &#123; height: 35px; /*统一每一行的默认高度*/ border: 1px solid #dedede; /*内部边框样式*/ padding: 0 10px; /*内边距*/&#125;table th &#123; font-weight: bold; /*加粗*/ text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/ background: rgba(158,188,226,0.2); /*背景色*/&#125;table th &#123; white-space: nowrap; /*表头内容强制在一行显示*/&#125;table td:nth-child(1) &#123; /*首列不换行*/ white-space: nowrap;&#125;table tbody tr:nth-child(2n) &#123; /*隔行变色*/ background: rgba(102, 128, 153, 0.05);&#125;table tr:hover &#123; background: rgba(245, 166, 5, 0.77);&#125; 在 themes/next/source/css/main.styl 文件的最底部，引入表格样式文件 注意：引用的文件路径为相对该 main.styl 的路径 1@import &quot;_custom/table.css&quot;; 样式更改前后对比 更改前 更改后","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/tags/Hexo/"}]},{"title":"React插件 - react-codemirror2","slug":"React插件-react-codemirror2","date":"2022-01-23T01:42:36.000Z","updated":"2022-01-23T08:21:20.262Z","comments":true,"path":"2022/01/23/React插件-react-codemirror2/","link":"","permalink":"https://hushaoyu.github.io/2022/01/23/React%E6%8F%92%E4%BB%B6-react-codemirror2/","excerpt":"简介 react-codemirror2 是基于 CodeMirror 工作原理，可以在React环境中直接使用的一个代码编辑器。 &ensp;&ensp; CodeMirror 是一个用 JavaScript 为浏览器实现的通用文本编辑器。它专门用于编辑代码，并带有多种语言模式和插件，可实现更高级的编辑功能。","text":"简介 react-codemirror2 是基于 CodeMirror 工作原理，可以在React环境中直接使用的一个代码编辑器。 &ensp;&ensp; CodeMirror 是一个用 JavaScript 为浏览器实现的通用文本编辑器。它专门用于编辑代码，并带有多种语言模式和插件，可实现更高级的编辑功能。 开始 安装1$ npm install react-codemirror2 codemirror --save 组件：UnControlled 和 Controlled react-codemirror2 有两种组件，一种是由 codemirror 本身内部的工作原理提供功能支持，非受控的组件 UnControlled；一种是通过 React 的状态 State 来进行数据控制的受控组件 Controlled。 文件说明 目录 说明 addon 可选的扩展功能配件 mode 编辑器当前支持的语言类型 src theme 编辑器的样式主题 特性 支持超过 100种 开箱即用的语言 强大的、可组合 的语言模式系统 代码提示，自动完成 提示功能 代码折叠 可配置的 快捷键绑定 可配置的，基于 Vim 、Emacs 、Sublime Text 的键映射绑定 查找和替换 操作界面 括号 和 标签 匹配 支持 拆分视图 集成 lint 进行语法检测 可配置的 字体大小和样式 大量的可配置 主题 能够调整大小以 自适应内容 内联 和 块级 的小部件 文本标记：受控样式 、只读 、原子 双向文本支持 ：LRT、RTL 搜索 使用 文件引入1234import &#123;Controlled as CodeMirror&#125; from &#x27;react-codemirror2&#x27;; // 受控组件import &#x27;codemirror/lib/codemirror.css&#x27;; // 编辑器主体样式import &#x27;codemirror/theme/material-darker.css&#x27;; // 编辑器使用 material-darker 主题import &#x27;codemirror/mode/properties/properties.js&#x27;; // 编辑器代码语言支持：properties 配置文件 组件配置12345678910111213141516171819state = &#123; value: _.get(this.props, &#x27;initialValue&#x27;, undefined),&#125;editorChange = (editor, data, value) =&gt; &#123; // 受控组件设置编辑器内容 this.setState(&#123; value &#125;);&#125;&lt;CodeMirror value=&#123;this.state.value&#125; options=&#123;&#123; width: 300, mode: &#x27;properties&#x27;, // 编辑器语言，需引入语言js文件 theme: &#x27;material-darker&#x27;, // 主题配置，需要引入主题样式文件 lineNumbers: true, // 显示行号 &#125;&#125; onBeforeChange=&#123;this.editorChange&#125;/&gt; 可组合的语言模式 编辑器可配置显示多种语言，如常见的 html 文件，就包含三种语言： html、JavaScript、css。官方语言模式中，html 文件有一个内置的集成语言模式配置值： htmlmixed html 语言是基于 xml 语言来解析的，因此如果需要单独配置 html 语言支持，需要引入的是 xml 语言配置 js 文件 引入语言模式文件1import &#x27;codemirror/mode/htmlmixed/htmlmixed.js&#x27;; // 引入语言模式js文件 修改配置中的 mode 属性123456options=&#123;&#123; width: 300, mode: &#x27;htmlmixed&#x27;, theme: &#x27;material-darker&#x27;, lineNumbers: true, // 显示行号&#125;&#125; 预览 修改前 修改后 代码提示，自动完成 目前插件支持的代码提示有 html、JavaScript、css、xml、sql，以及 anyword，anyword 指在当前文本输入光标附近查找相应的词语进行自动提示。 以 sql 为例，引入相应的 css 样式 及 js 脚本1234import &#x27;codemirror/addon/hint/show-hint.css&#x27;;import &#x27;codemirror/mode/sql/sql.js&#x27;;import &#x27;codemirror/addon/hint/show-hint.js&#x27;import &#x27;codemirror/addon/hint/sql-hint.js&#x27;; option 添加 hintOptions 配置12345678910options=&#123;&#123; width: 300, mode: &#x27;sql&#x27;, theme: &#x27;material-darker&#x27;, hintOptions: &#123; completeSingle: false &#125;, lineNumbers: true, // 显示行号 styleActiveLine: true, // 选中行高亮&#125;&#125; 在 onBeforeChange 方法内调用 .showHint() 方法1234567editorChange = (editor, data, value) =&gt; &#123; editor.showHint(); this.setState(&#123; value &#125;); _.isFunction(this.props.editorChange) &amp;&amp; this.props.editorChange(value);&#125; 代码折叠 引入样式及脚本文件123456// 折叠import &#x27;codemirror/addon/fold/foldgutter.css&#x27;;import &#x27;codemirror/addon/fold/foldcode&#x27;;import &#x27;codemirror/addon/fold/foldgutter&#x27;;import &#x27;codemirror/addon/fold/brace-fold&#x27;;import &#x27;codemirror/addon/fold/comment-fold&#x27;; option 添加配置123foldGutter: true, // 支持折叠lineWrapping: true,gutters: [&#x27;CodeMirror-linenumbers&#x27;, &#x27;CodeMirror-foldgutter&#x27;, &#x27;CodeMirror-lint-markers&#x27;], 搜索 引入样式及脚本文件12345678910// 搜索import &#x27;codemirror/addon/scroll/annotatescrollbar.js&#x27;import &#x27;codemirror/addon/search/matchesonscrollbar.js&#x27;import &#x27;codemirror/addon/search/match-highlighter.js&#x27;import &#x27;codemirror/addon/search/jump-to-line.js&#x27;import &#x27;codemirror/addon/dialog/dialog.js&#x27;import &#x27;codemirror/addon/dialog/dialog.css&#x27;import &#x27;codemirror/addon/search/searchcursor.js&#x27;import &#x27;codemirror/addon/search/search.js&#x27; 使用快捷键 ctrl + F 查找 支持的快捷键 快捷键 描述 ctrl + F 查找 ctrl + G 查找下一个 shift + ctrl + F 查找上一个 shift + ctrl + F 替换 shift + ctrl + R 替换全部 使用图形交互执行查找替换使用快捷键 &ensp;&ensp;对于不习惯使用快捷键方式的用户，可以提供 UI 控件，来唤起查找对话框 12345678910111213141516editor = null;mounted = editor =&gt; &#123; this.editor = editor;&#125;find = () =&gt; &#123; this.editor &amp;&amp; this.editor.execCommand(&#x27;find&#x27;);&#125;&lt;Row&gt; &lt;Col&gt; &lt;Button onClick=&#123;this.find&#125;&gt;查找&lt;/Button&gt; &lt;/Col&gt;&lt;/Row&gt;&lt;CodeMirror editorDidMount=&#123;this.mounted&#125; value=&#123;this.state.value&#125; /&gt; 其他相关指令用法123456789101112findNext = () =&gt; &#123; this.editor &amp;&amp; this.editor.execCommand(&#x27;findNext&#x27;);&#125;findPrev = () =&gt; &#123; this.editor &amp;&amp; this.editor.execCommand(&#x27;findPrev&#x27;);&#125;replace = () =&gt; &#123; this.editor &amp;&amp; this.editor.execCommand(&#x27;replace&#x27;);&#125;replaceAll = () =&gt; &#123; this.editor &amp;&amp; this.editor.execCommand(&#x27;replaceAll&#x27;);&#125; 所有可用的指令 语法校验 插件目前支持语法校验有：javaScript、coffeeScript、css、html、xml、json，以下以 JavaScript 为例 引入样式及脚本文件1234// 语法错误提示import &#x27;codemirror/addon/lint/lint.css&#x27;;import &#x27;codemirror/addon/lint/lint.js&#x27;;import &#x27;codemirror/addon/lint/javascript-lint.js&#x27;; option 内添加新的配置，启用检测1lint: true, 启动项目，发现语法检测并没生效，并且控制台报 JSHINT 相关的错误 查找资料，发现插件内的 JavaScript 检测依赖第三方插件 jslint，因此需要在项目中安装该插件，并全局设置该变量1$ npm install jslint --save 12import &#123; JSHINT &#125; from &quot;jshint&quot;;window.JSHINT = JSHINT; 重新启动项目，可以看到 JavaScript 语法检测生效了 配合 React 的 state 设置，在出现语法错误时，不允许提交123456789101112131415161718192021state = &#123; value: _.get(this.props, &#x27;initialValue&#x27;, undefined), validFlag: true&#125;editorChange = (editor, data, value) =&gt; &#123; editor.showHint(); // 获取校验状态 const validFlag = this.validCheck(_.get(editor, &#x27;state.lint.marked&#x27;, [])); this.setState(&#123; value, validFlag &#125;); _.isFunction(this.props.editorChange) &amp;&amp; this.props.editorChange(value);&#125;// 根据类名判断是否出现错误语法validCheck = (marks) =&gt; &#123; if (_.isEmpty(marks)) return true; const errorFlag = _.isArray(marks) &amp;&amp; marks.findIndex(item =&gt; item.className.indexOf(&#x27;error&#x27;) &gt;= 0); return errorFlag &lt; 0;&#125; 代码合并 参考文档","categories":[{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/categories/React/"},{"name":"插件","slug":"React/插件","permalink":"https://hushaoyu.github.io/categories/React/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/tags/React/"},{"name":"插件","slug":"插件","permalink":"https://hushaoyu.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"react-codemirror2","slug":"react-codemirror2","permalink":"https://hushaoyu.github.io/tags/react-codemirror2/"}]},{"title":"Echarts - 开发笔记","slug":"Echarts-开发笔记","date":"2022-01-18T06:49:12.000Z","updated":"2022-01-18T09:28:09.764Z","comments":true,"path":"2022/01/18/Echarts-开发笔记/","link":"","permalink":"https://hushaoyu.github.io/2022/01/18/Echarts-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"更新渲染会残留之前的数据 在 setOption 时添加一个额外的参数 true1this.chart.setOption(this.option, true); setOption 参数说明请参考 文档","text":"更新渲染会残留之前的数据 在 setOption 时添加一个额外的参数 true1this.chart.setOption(this.option, true); setOption 参数说明请参考 文档 全屏显示图表 全屏、退出全屏1234567891011121314151617181920212223242526//全屏显示export function fullScreen(ele) &#123; let element = ele || document.documentElement; if (element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(); &#125;&#125;//退出全屏export function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125;&#125; 触发12345handle = () =&gt; &#123; if (this.chart) &#123; fullScreen(this.chart._dom.parentElement); &#125;&#125; 全屏状态下，背景色设置1234567891011121314//各个浏览器下 全屏状态下背景色设置:-webkit-full-screen &#123; background-color: $content-bg !important;&#125;:-moz-full-screen &#123; background-color: $content-bg !important;&#125;:-ms-fullscreen &#123; background-color: $content-bg !important;&#125;:fullscreen &#123; background-color: $content-bg !important;&#125; 折线图需求：同一天内可能存在一条、两条或者三条数据 构造X轴数据、配置axisLabel及axisTick及formatter123456789101112131415161718192021222324252627option = &#123; ... xAxis: [ &#123; ... axisTick: &#123; interval: (index, indexName) =&gt; indexName.length &lt; 11 &#125;, axisLabel: &#123; interval: (index, indexName) =&gt; indexName.length &lt; 11 &#125;, data: [ &#x27;2009/6/12&#x27;, &#x27;2009/6/12 12&#x27;, &#x27;2009/6/12 12&#x27;, &#x27;2009/6/13&#x27;, &#x27;2009/6/13 12&#x27;, &#x27;2009/6/14&#x27;], &#125; ], series: [ &#123; ... data: [ 3.75,3.75,5.66,6.95,0.95,0.94,0.94,0.94,0.94,0.94, 0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94, 0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94, 0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94] &#125;, ]&#125;; 自定义触发行为 手动缩放 dataZoom 单个缩放12345myChart.dispatchAction(&#123; type: &#x27;dataZoom&#x27;, start: 20, end: 30&#125;); 批量缩放12345678910111213myChart.dispatchAction(&#123; type: &#x27;dataZoom&#x27;, batch: [&#123; // 第一个 dataZoom 组件 start: 20, end: 30 &#125;, &#123; // 第二个 dataZoom 组件 dataZoomIndex: 1, start: 10, end: 20 &#125;]&#125;); 轮播高亮显示1234567891011121314151617181920getEchart = (chart) =&gt; &#123; if (chart &amp;&amp; _.isFunction(chart) &amp;&amp; !this.timer) &#123; const instance = chart(); // 记录当前轮播的数据索引 let index = 0; this.timer = setInterval(() =&gt; &#123; // 用户鼠标 hover 时，停止轮播 !this.state.hovered &amp;&amp; instance &amp;&amp;instance.dispatchAction(&#123; type: &#x27;showTip&#x27;, seriesIndex: 0, dataIndex: index &#125;); // 用户鼠标 hover 时，停止轮播数据项计数，hover交互移除后，继续当前索引进行轮播 !this.state.hovered &amp;&amp; index++; if (index &gt; this.state.list.length - 1) &#123; index = 0; &#125; &#125;, 2000); &#125;&#125; 饼图内标题文字自适应显示 options 配置，动态设置字体大小123456789101112title: [ &#123; text: _.get(this.state, `chartData.$&#123;day&#125;`, 0), top: &#x27;32%&#x27;, left: &quot;center&quot;, textStyle: &#123; color: &#x27;#FF0014&#x27;, fontSize: this.getFontSize(_.get(this.state, `chartData.$&#123;day&#125;`, 0)), fontWeight: 600, &#125;, &#125;] 获取自适应后的字体大小12345678910111213getFontSize = (value) =&gt; &#123; const screenWidth = document.body.clientWidth; let fontSize = 12; const valueLength = _.isNumber(value) &amp;&amp; value.toString().length; if (screenWidth &gt;= 1900) &#123; fontSize = this.generateSize(120, valueLength); &#125; else if (screenWidth &lt; 1920 &amp;&amp; screenWidth &gt;= 1660) &#123; fontSize = this.generateSize(100, valueLength); &#125; else if (screenWidth &lt; 1680 &amp;&amp; screenWidth &gt;= 1400) &#123; fontSize = this.generateSize(80, valueLength); &#125; return fontSize;&#125; 限定字体大小范围12345678910generateSize = (size, length) =&gt; &#123; const fontSize = Math.ceil(size / length); if (fontSize &gt; 26) &#123; return 26; &#125; else if (fontSize &lt; 8) &#123; return 8; &#125; else &#123; return fontSize; &#125;&#125; 根据y轴刻度标签文本动态设置边距 获取Y轴文本长度最长的一项1const maxLabel = _.get(yData.slice().sort((pre, next) =&gt; computedTextWidth(next) - computedTextWidth(pre)), &#x27;[0]&#x27;, &#x27;&#x27;); options 配置1234567grid: &#123; borderWidth: 0, top: 15, bottom: 20, right: computedTextWidth(maxValue) + 18, left: computedTextWidth(maxLabel, 12, true) + 18,&#125; 计算文本长度工具方法1234567891011121314151617181920/** * @description 计算字符串在浏览器中显示的宽度 * @param text &#123;string|number&#125; 需要计算的文本 * @param fontSize &#123;number&#125; 文本字体大小 * @param overflowFlag &#123;boolean&#125; 是否超长省略显示 * @return &#123;number&#125; */export const computedTextWidth = (text, fontSize = 12, overflowFlag) =&gt; &#123; let span = document.getElementById(&#x27;computedTextWidth&#x27;); if (!span) &#123; span = document.createElement(&#x27;span&#x27;); span.id = &#x27;computedTextWidth&#x27;; span.style.cssText = &#x27;visibility:hidden;position: absolute;left: -999em;top:-999em;&#x27;; document.body.appendChild(span); &#125; span.style.fontSize = `$&#123;fontSize&#125;px`; // 如果设置超长省略显示，则超出8个字符串后，接省略号显示 span.innerHTML = overflowFlag &amp;&amp; _.isString(text) &amp;&amp; text.length &gt; 8 ? `$&#123;text.slice(0, 8)&#125;...` : text; return span.offsetWidth;&#125;; legend 文本过长换行显示 legend 配置项设置1234567891011legend: &#123; top:&#x27;20%&#x27;, width:222, right:30, orient: &#x27;vertical&#x27;, type: &#x27;scroll&#x27;, data: this.props.userList, formatter: function (params) &#123; return formatterLegendText(params); &#125;&#125; 工具方法1234567891011121314151617181920212223242526272829303132333435363738394041/** * 格式化legend 文本过长换行显示 * @params: * params: 文本 * provideNumber: 每一行要显示的文本字数 * rows: 指定最多显示多少行 * */export const formatterLegendText = (params, provideNumber = 17, rows) =&gt; &#123; //超过十个字符就换行展示 let newParamsName = &quot;&quot;;// 最终拼接成的字符串 const paramsNameNumber = params.length;// 实际标签的个数 // const provideNumber = 17;// 每行能显示的字的个数 const maxRows = Math.ceil(paramsNameNumber / provideNumber);// 换行的话，需要显示几行，向上取整; let rowNumber = rows || maxRows; // 条件等同于rowNumber&gt;1 if (paramsNameNumber &gt; provideNumber) &#123; for (let p = 0; p &lt; rowNumber; p += 1) &#123; let tempStr = &quot;&quot;;// 表示每一次截取的字符串 let start = p * provideNumber;// 开始截取的位置 let end = start + provideNumber;// 结束截取的位置 // 此处特殊处理最后一行的索引值 if (p == rowNumber - 1) &#123; // 最后一次不换行 tempStr = params.substring(start, paramsNameNumber); &#125; else &#123; // 每一次拼接字符串并换行 tempStr = params.substring(start, end) + &quot;\\n&quot;; &#125; newParamsName += tempStr;// 最终拼成的字符串 &#125; &#125; else &#123; // 将旧标签的值赋给新标签 newParamsName = params; &#125; if (rows &amp;&amp; rows &lt; maxRows) &#123; newParamsName += &#x27;...&#x27;; &#125; //将最终的字符串返回 return newParamsName&#125; 将某个省份地区，切割成两部分显示 引入完整天津地图1import chinaCity from &#x27;echarts/map/json/province/tianjin.json&#x27;; 通过地区代码定义需要分割的副地图区域数据1subMapArea = [&#x27;120101&#x27;,&#x27;120102&#x27;,&#x27;120103&#x27;,&#x27;120104&#x27;,&#x27;120105&#x27;,&#x27;120106&#x27;]; 通过区域数据，将完整地图json数据划分为两份地图数据，并注册地图名称123456789101112131415161718192021222324componentWillMount() &#123; const mainMap = _.cloneDeep(chinaCity); const subMap = _.cloneDeep(chinaCity); const mainFeatures = [], subFeatures = []; chinaCity.features.map(item =&gt; &#123; if (this.subMapArea.indexOf(item.id) &lt; 0) &#123; mainFeatures.push(_.cloneDeep(item)); &#125; else &#123; subFeatures.push(_.cloneDeep(item)); &#125; &#125;); mainMap.features = _.cloneDeep(mainFeatures); subMap.features = _.cloneDeep(subFeatures); echarts.registerMap(&#x27;mainMap&#x27;, mainMap); echarts.registerMap(&#x27;subMap&#x27;, subMap); mainMap.features.map((&#123;properties: &#123;cp = [], name = &#x27;&#x27;&#125;, id&#125;) =&gt; &#123; this.geoCoordMap[name] = cp.slice(); return; &#125;); subMap.features.map((&#123;properties: &#123;cp = [], name = &#x27;&#x27;&#125;, id&#125;) =&gt; &#123; this.subGeoCoordMap[name] = cp.slice(); return; &#125;);&#125; 在各自的option中geo的定义中，使用不同的地图名称显示地图轮廓123456geo: [ &#123; map:&#x27;mainMap&#x27;, ... &#125;,]","categories":[{"name":"Echarts","slug":"Echarts","permalink":"https://hushaoyu.github.io/categories/Echarts/"}],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://hushaoyu.github.io/tags/Echarts/"},{"name":"开发笔记","slug":"开发笔记","permalink":"https://hushaoyu.github.io/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}]},{"title":"微信小程序 - 开发笔记","slug":"微信小程序-开发笔记","date":"2022-01-17T06:13:12.000Z","updated":"2022-01-17T08:21:58.424Z","comments":true,"path":"2022/01/17/微信小程序-开发笔记/","link":"","permalink":"https://hushaoyu.github.io/2022/01/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"data-* 指令 用于将 wxml 页面的数据传递至后台 js","text":"data-* 指令 用于将 wxml 页面的数据传递至后台 js wxml 代码123456789&lt;view class=&#x27;container&#x27;&gt; &lt;view class=&#x27;nav_left&#x27;&gt; &lt;block wx:for=&quot;&#123;&#123;navLeftItems&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;view class=&#x27;nav_left_items&#x27; bindtap=&#x27;switchItem&#x27; data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt; &#123;&#123;item.categoryName&#125;&#125; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt;&lt;/view&gt; js 代码：通过 event 参数获取需要传递的 data-* 参数123switchItem: function(event) &#123; console.log(event.target.dataset.id);&#125; 路由跳转方式及区别 wx.switchTab 跳转至 tabBar 页面，并关闭其他非 tabBar 页面 参数说明 属性 类型 默认值 是否必须 说明 url string / 是 需要跳转的 tabBar 页面的路径（需在 app.json 的 tabBar 字段定义的页面），路径后不能带参数（传参可用全局变量） success function / 否 接口调用成功的回调函数 fail function / 否 接口调用失败的回调函数 complete function / 否 接口调用结束的回调函数（无论成功或失败，都会执行） 代码示例1234// 跳转wx.switchTab(&#123; url: &#x27;/pages/catagory/catagory&#x27;,&#125;); wx.navigationTo 保留当前页面，跳转至应用内的某个页面。但是不能跳转至 tabBar 页面。调用此方法，页面会被加入堆栈，可以使用 wx.navigateBack 执行返回上一页操作。 参数说明 属性 类型 默认值 是否必须 说明 url string / 是 需要跳转的应用内非 tabBar 的页面的路径, 路径后可以带参数。参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 path?key=value&amp;key2=value2 events object / 否 页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持 success function / 否 接口调用成功的回调函数 fail function / 否 接口调用失败的回调函数 complete function / 否 接口调用结束的回调函数（无论成功或失败，都会执行） 代码示例 1234567891011// 跳转confirmSearch: function (event) &#123; wx.navigateTo(&#123; url: `/pages/product_list/product_list?name=$&#123;event.detail.value&#125;`, &#125;)&#125;// 参数接收onLoad: function (options) &#123; const searchName = options.name || &#x27;&#x27;; ... &#125; wx.redirectTo 关闭当前页面，跳转至应用内的某个页面。但是不能跳转至 tabBar 页面。调用此方法，页面不会被加入堆栈，无法使用 wx.navigateBack 执行返回上一页操作。 参数说明 属性 类型 默认值 是否必须 说明 url string / 是 需要跳转的应用内非 tabBar 的页面的路径, 路径后可以带参数。参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 path?key=value&amp;key2=value2 success function / 否 接口调用成功的回调函数 fail function / 否 接口调用失败的回调函数 complete function / 否 接口调用结束的回调函数（无论成功或失败，都会执行） 使用方法与 wx.navigateTo 类似 wx.navigateBack 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层 参数说明 属性 类型 默认值 是否必须 说明 delta number / 是 返回的页面数，如果 delta 大于现有页面数，则返回到首页 success function / 否 接口调用成功的回调函数 fail function / 否 接口调用失败的回调函数 complete function / 否 接口调用结束的回调函数（无论成功或失败，都会执行） 代码示例 123456789101112// 此处是A页面wx.navigateTo(&#123; url: &#x27;B?id=1&#x27;&#125;)// 此处是B页面wx.navigateTo(&#123; url: &#x27;C?id=1&#x27;&#125;)// 在C页面内 navigateBack，将返回A页面wx.navigateBack(&#123; delta: 2&#125;) wx.reLaunch 关闭所有页面，打开到应用内的某个页面 参数说明 属性 类型 默认值 是否必须 说明 url string / 是 需要跳转的页面的路径, 路径后可以带参数。参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 path?key=value&amp;key2=value2 success function / 否 接口调用成功的回调函数 fail function / 否 接口调用失败的回调函数 complete function / 否 接口调用结束的回调函数（无论成功或失败，都会执行） wxml 中使用三目运算符1234&lt;view class=&quot;&#123;&#123;activeFilterName===&#x27;sale&#x27; ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtap=&#x27;onClickFilter&#x27; data-name=&#x27;sale&#x27;&gt;销量&lt;/view&gt;&lt;view class=&quot;&#123;&#123;activeFilterName===&#x27;new_product&#x27; ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtap=&#x27;onClickFilter&#x27; data-name=&#x27;new_product&#x27;&gt;新品&lt;/view&gt;&lt;view class=&quot;&#123;&#123;activeFilterName===&#x27;high_praise&#x27; ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtap=&#x27;onClickFilter&#x27; data-name=&#x27;high_praise&#x27;&gt;好评&lt;/view&gt;&lt;view class=&quot;&#123;&#123;activeFilterName===&#x27;price&#x27; ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtap=&#x27;onClickFilter&#x27; data-name=&#x27;price&#x27;&gt; 设置和获取全局变量 getApp() 是一个全局函数，在应用内所有页面可以使用。 设置12345678// 用户自定义方法hotItemClick: function(event) &#123; getApp().globalData.activeItemName = event.currentTarget.dataset.name; getApp().globalData.activeItemIndex = event.currentTarget.dataset.index; wx.switchTab(&#123; url: &#x27;/pages/catagory/catagory&#x27;, &#125;);&#125; 获取1234567891011onLoad: function (options) &#123; this.getCategory(); const activeItemName = getApp().globalData.activeItemName; const activeItemIndex = getApp().globalData.activeItemIndex; if (activeItemName &amp;&amp; activeItemIndex) &#123; this.setData(&#123; activeItem: activeItemName, activeIndex: activeItemIndex, &#125;); &#125; &#125; 页面设置背景色 wxss 配置123page &#123; background-color: #eaeaea;&#125; 隐藏与显示元素 wx:if showClass 为 true 时显示，为 false 时隐藏。123&lt;view class=&#x27;official_wrapper&#x27; wx:if=&quot;&#123;&#123;showClass&#125;&#125;&quot;&gt; &lt;official-account class=&quot;official&quot; bindload=&quot;loadOfficial&quot; binderror=&quot;errorOfficial&quot;&gt;&lt;/official-account&gt;&lt;/view&gt; hidden faceShow 为 true 时显示，为 false 时隐藏。1&lt;button hidden=&quot;&#123;&#123;faceShow&#125;&#125;&quot; bindtap=&quot;toFace&quot;&gt;人脸识别&lt;/button&gt; 区别 wx:if 在隐藏的时候，元素会被销毁不渲染，而 hidden 在隐藏时仍然渲染，只是不呈现。 因此出于对性能的考虑，如果该元素需要频繁的进行显示隐藏操作，则选择使用 hidden 属性进行控制。如果该元素只在初始化的时候需要设置其是否显示，则使用 wx:if 进行处理。 阿里云OSS图片缩略图 使用方法 图片路径后面拼接如下路径： 格式：?x-oss-process=image/[处理类型],x_100,y_50[宽高等参数] 示例：?x-oss-process=image/resize,m_fill,h_100,w_200,limit_0 原图 https://hsj-studio.oss-cn-shanghai.aliyuncs.com/blog/articles/Hexo-Note-%E4%BD%BF%E7%94%A8NexT%E4%B8%BB%E9%A2%98/home.png 缩略图 https://hsj-studio.oss-cn-shanghai.aliyuncs.com/blog/articles/Hexo-Note-%E4%BD%BF%E7%94%A8NexT%E4%B8%BB%E9%A2%98/home.png?x-oss-process=image/resize,m_fill,h_100,w_200,limit_0 参考文档 阿里云OSS视频预览图 OSS 提供的视频截帧功能和 OSS 图片服务功能使用的方式是类似的，都是通过传入 x-oss-process 参数的方式来实现的。最简单的使用方式就是直接在 url 后面拼接处理字符串。比如如下的 url：http://a-image-demo.oss-cn-qingdao.aliyuncs.com/demo.mp4?x-oss-process=video/snapshot,t_10000,m_fast 指定的就是对 demo.mp4 这个文件直接调用视频截图，截图的位置由参数 t 指定，后面的单位是 ms，因此这个 url 的含义就是截取视频文件的第 10s 的内容。生成的 url 可以直接嵌入在网页提供给用户浏览。 控制图片输出大小 视频截帧功能支持选择输出图片的大小，使用 w 参数指定宽度，h 指定长度; 不指定 w 和 h 参数，或者 w 和 h 都指定为 0，输出的图片大小为视频的真实长宽; 单独指定 w 或者 h 参数，输出的图片大小指定的数值，另外一个没有指定的数值通过视频原始比例自动计算出来; 同时指定 w 和 h 参数，输出图片大小为指定的数值，如果长宽比例和原始视频比不相等则强制拉伸; 比如下面这个 url 就是将输出的图片大小指定为 800 宽度 输出格式：OSS 输出的视频格式支持 jpg 和 png 两种格式，可以通过 f 参数来切换，默认输出的是 jpg 格式，对于没有特殊需求的用户无需指定该参数http://a-image-demo.oss-cn-qingdao.aliyuncs.com/demo.mp4?x-oss-process=video/snapshot,t_10000,m_fast,w_800 参考文档 保存 base64 格式的图片1234567891011121314151617181920212223const saveImg = wx.getFileSystemManager()const number = Math.random()saveImg.writeFile(&#123; filePath: wx.env.USER_DATA_PATH + &#x27;/pic&#x27; + number + &#x27;.png&#x27;, data: fileData, encoding: &#x27;base64&#x27;, success: res =&gt; &#123; wx.saveImageToPhotosAlbum(&#123; filePath: wx.env.USER_DATA_PATH + &#x27;/pic&#x27; + number + &#x27;.png&#x27;, success: function (res) &#123; wx.showToast(&#123; title: &#x27;保存成功&#x27;, &#125;) &#125;, fail: function (err) &#123; console.log(err) &#125; &#125;) console.log(res) &#125;, fail: err =&gt; &#123; console.log(err) &#125;&#125;) 小程序列表渲染 wx:for 中自定义 index,item123&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;in&quot; wx:for-item=&quot;it&quot;&gt; &lt;view&gt;&#123;&#123;in&#125;&#125;:&#123;&#123;it&#125;&#125;&lt;/view&gt;&lt;/block&gt; 微信开放能力 open-type 参考文档 合法值 说明 锚点 contact 打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息 跳转 share 触发用户转发 跳转 getPhoneNumber 获取用户手机号，可以从 bindgetphonenumber 回调中获取到用户信息 跳转 getUserInfo 获取用户信息，可以从 bindgetuserinfo 回调中获取到用户信息 跳转 launchApp 打开 APP，可以通过 app-parameter 属性设定向 APP 传的参数 跳转 openSetting 打开授权设置页 跳转 feedback 打开“意见反馈”页面，用户可提交反馈内容并上传日志，开发者可以登录小程序管理后台后进入左侧菜单“客服反馈”页面获取到反馈内容 跳转 chooseAvatar 获取用户头像，可以从 bindchooseavatar 回调中获取到头像信息 跳转 微信小程序组件之 button 客服会话功能 先登录 微信公众平台 ，如果没有账户可以去申请一个微信小程序账号. 在微信公众平台启动小程序客服推送，点击客服反馈来添加客服人员(客服人员可以添加100个). 打开 微信公众平台客服 ，使用绑定的微信号扫码登录，点击登录进入微信公众平台客服界面. 那么就开始愉快的敲代码1&lt;button open-type=&quot;contact&quot; bindcontact=&quot;handleContact&quot;&gt;客服&lt;/button&gt;","categories":[{"name":"微信小程序，开发笔记","slug":"微信小程序，开发笔记","permalink":"https://hushaoyu.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"微信小程序，开发笔记","slug":"微信小程序，开发笔记","permalink":"https://hushaoyu.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}]},{"title":"nodeppt - css","slug":"nodeppt-css","date":"2022-01-14T08:23:10.000Z","updated":"2022-01-14T08:23:32.120Z","comments":true,"path":"2022/01/14/nodeppt-css/","link":"","permalink":"https://hushaoyu.github.io/2022/01/14/nodeppt-css/","excerpt":"","text":"","categories":[{"name":"nodeppt","slug":"nodeppt","permalink":"https://hushaoyu.github.io/categories/nodeppt/"}],"tags":[{"name":"nodeppt","slug":"nodeppt","permalink":"https://hushaoyu.github.io/tags/nodeppt/"}]},{"title":"生成PPT - nodeppt","slug":"生成PPT-nodeppt","date":"2022-01-14T07:25:16.000Z","updated":"2022-01-14T08:22:29.628Z","comments":true,"path":"2022/01/14/生成PPT-nodeppt/","link":"","permalink":"https://hushaoyu.github.io/2022/01/14/%E7%94%9F%E6%88%90PPT-nodeppt/","excerpt":"全局安装脚本1$ npm install -g nodeppt","text":"全局安装脚本1$ npm install -g nodeppt github 使用方法 命令 new：使用线上模板创建一个md文件 nodeppt new demo.md # 根据官方模板创建一个新的 slide 板块 nodeppt new demo.md -t username/repo # 根据 github 指定模板创建新的 slide板块 serve：启动一个指定的md文件预览 build：编译产出一个md文件 快捷键12345Page: ↑/↓/←/→ Space Home EndFullscreen: FOverview: -/+Speaker Note: NGrid Background: Enter 配置12345678910title: nodeppt markdown 演示speaker: 三水清url: https://github.com/ksky521/nodepptjs: - https://www.echartsjs.com/asset/theme/shine.jsprismTheme: solarizedlightplugins: - echarts - mermaid - katex title：演讲主题 speaker：演讲人 url：地址 js：需要加载的 js 文件数组，将被放在 body 标签之前 css：需要加载的 css 文件数组，将被放在 head 标签内 prismTheme：prism 配色，取值范围 [&#39;dark&#39;, &#39;coy&#39;, &#39;funky&#39;, &#39;okaidia&#39;, &#39;tomorrow&#39;, &#39;solarizedlight&#39;, &#39;twilight&#39;] plugins：主题配色插件，目前支持的有 echarts 、mermaid 、katex 语法","categories":[{"name":"PPT","slug":"PPT","permalink":"https://hushaoyu.github.io/categories/PPT/"},{"name":"nodeppt","slug":"PPT/nodeppt","permalink":"https://hushaoyu.github.io/categories/PPT/nodeppt/"}],"tags":[{"name":"nodeppt","slug":"nodeppt","permalink":"https://hushaoyu.github.io/tags/nodeppt/"},{"name":"PPT","slug":"PPT","permalink":"https://hushaoyu.github.io/tags/PPT/"}]},{"title":"React 基础开发框架搭建","slug":"React-基础开发框架搭建","date":"2022-01-14T02:02:01.000Z","updated":"2022-01-14T02:15:50.078Z","comments":true,"path":"2022/01/14/React-基础开发框架搭建/","link":"","permalink":"https://hushaoyu.github.io/2022/01/14/React-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/","excerpt":"简介 &ensp;&ensp;Create React App 是一种官方支持的创建单页 React 应用程序的方式。它提供了一个没有配置的现代构建设置。","text":"简介 &ensp;&ensp;Create React App 是一种官方支持的创建单页 React 应用程序的方式。它提供了一个没有配置的现代构建设置。","categories":[{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/categories/React/"},{"name":"create-react-app","slug":"React/create-react-app","permalink":"https://hushaoyu.github.io/categories/React/create-react-app/"}],"tags":[{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/tags/React/"},{"name":"框架搭建","slug":"框架搭建","permalink":"https://hushaoyu.github.io/tags/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"},{"name":"creat-react-app","slug":"creat-react-app","permalink":"https://hushaoyu.github.io/tags/creat-react-app/"}]},{"title":"webpack - 技巧篇","slug":"webpack-技巧篇","date":"2022-01-14T01:56:14.000Z","updated":"2022-01-14T02:01:15.564Z","comments":true,"path":"2022/01/14/webpack-技巧篇/","link":"","permalink":"https://hushaoyu.github.io/2022/01/14/webpack-%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"打包图片资源 安装 loader1$ npm install --save-dev file-loader 在 webpack.config.js 文件的规则中添加配置1234&#123; test: /\\.(png|svg|jpg|gif)$/, use: [&#x27;file-loader&#x27;]&#125;","text":"打包图片资源 安装 loader1$ npm install --save-dev file-loader 在 webpack.config.js 文件的规则中添加配置1234&#123; test: /\\.(png|svg|jpg|gif)$/, use: [&#x27;file-loader&#x27;]&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://hushaoyu.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://hushaoyu.github.io/tags/webpack/"}]},{"title":"CSS - 开发技巧","slug":"CSS-开发技巧","date":"2022-01-13T07:58:19.000Z","updated":"2022-01-21T05:22:26.257Z","comments":true,"path":"2022/01/13/CSS-开发技巧/","link":"","permalink":"https://hushaoyu.github.io/2022/01/13/CSS-%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/","excerpt":"","text":"","categories":[{"name":"CSS","slug":"CSS","permalink":"https://hushaoyu.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://hushaoyu.github.io/tags/CSS/"},{"name":"开发技巧","slug":"开发技巧","permalink":"https://hushaoyu.github.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"}]},{"title":"Hexo Note - 使用NexT主题","slug":"Hexo-Note-使用NexT主题","date":"2022-01-10T02:08:41.000Z","updated":"2022-01-26T09:05:18.169Z","comments":true,"path":"2022/01/10/Hexo-Note-使用NexT主题/","link":"","permalink":"https://hushaoyu.github.io/2022/01/10/Hexo-Note-%E4%BD%BF%E7%94%A8NexT%E4%B8%BB%E9%A2%98/","excerpt":"简介 &ensp;&ensp;«NexT» is a high quality elegant Hexo theme. It is crafted from scratch with love.","text":"简介 &ensp;&ensp;«NexT» is a high quality elegant Hexo theme. It is crafted from scratch with love. 安装安装 进入hexo项目根目录，执行以下代码，将主题克隆至themes文件夹：12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 在项目的根配置文件 _config.yml 中，将 theme 的配置值修改为 next 应用主题，重新执行构建命令更新程序。1theme: next Tips：每次更新项目需要执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 才能应用本地更新，略显麻烦，可以在 package.json 文件中添加 start 命令，有改动只需要执行 npm start 就可以了1&quot;start&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo s&quot; 配置主题切换 NexT默认集成了4中主题模式，Gemini、Mist、Muse、Pisces。在项目配置文件中修改 scheme 来应用不同的主题模式。 隐藏网站页面底部的 powered by 在文件 themes/next/layout/_partials/footer.swig 中，将 footer.powered 代码块使用 &lt;!-- --&gt; 注释掉。1234567891011&lt;!--&#123;%- if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt; &#123;%- set next_site = &#x27;https://theme-next.org&#x27; %&#125; &#123;%- if theme.scheme !== &#x27;Gemini&#x27; %&#125; &#123;%- set next_site = &#x27;https://&#x27; + theme.scheme | lower + &#x27;.theme-next.org&#x27; %&#125; &#123;%- endif %&#125; &#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;, &#123;class: &#x27;theme-link&#x27;&#125;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme, &#123;class: &#x27;theme-link&#x27;&#125;)) &#125;&#125; &lt;/div&gt;&#123;%- endif %&#125;--&gt; 文章添加阴影 在文件 themes/next/source/css/_common/components/post/post.styl 中添加如下样式：12345.post &#123; margin-top: 20px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 设置各板块的背景透明度 在文件 themes/next/source/css/_schemes/Pisces/_layout.styl 中可以看到，板块的 background 属性，配置的都是 --content-bg-color 变量，因此我们只需找到这个变量所在的位置进行修改既可以了。 在项目中搜索，可以找到是在 themes/next/source/css/_variables/base.styl 文件中进行配置的，将其值修改如下12$body-bg-color = rgba(255,255,255,.8);$content-bg-color = rgba(255,255,255,.8); 设置网站图标 favicon.ico 在文件夹 /themes/next/source/images 中，有不同场景不同格式的网站图标，根据格式进行替换。 其他可自定义配置图标 avatar.gif：网站个人介绍logo 修改博客底部标签样式 在文件 /themes/next/layout/_macro/post.swig 中，搜索 rel=&quot;tag&quot;，将#替换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 显示当前页面的浏览进度 NexT默认已经集成该功能，在主题配置文件中，将 scrollpercent 的配置值设置为 true，在页面右下角即可看到图标。123456back2top: enable: true # Back to top in sidebar. sidebar: false # Scroll percent label in b2t button. scrollpercent: true 修改链接文字样式 在文件 themes/next/source/css/_common/components/post/post.styl 中，添加以下代码12345678.post-body a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #ff106c; text-decoration: underline; &#125;&#125; 设置引用块样式 在文件 themes/next/source/css/_common/scaffolding/base.styl 中添加如下样式12345blockquote &#123; border-left: 4px solid #f39406; box-shadow: 0 0 3px 3px #6e6d6d91; border-radius: 3px;&#125; 设置可折叠内容样式 在 themes/next/source/css/_custom 路径下新建文件 default.css123456789101112131415details &#123; padding: 4px 6px; box-shadow: 0 0 3px 3px #666565ad; border-radius: 5px;&#125;details:hover &#123; box-shadow: 0 0 3px 3px rgba(101, 243, 243, 0.71);&#125;details &gt; summary &#123; cursor: pointer; text-decoration: underline;&#125;details &gt; summary:hover &#123; text-decoration: none;&#125; 在 themes/next/source/css/main.styl 文件底部引入上述新增样式文件1@import &quot;_custom/default.css&quot;; 设置头像的悬停效果 在主题配置文件中，找到 avatar 配置，将其 rotated 属性设置为 true12345678# Sidebar Avataravatar: # Replace the default image and set the url here. url: /images/avatar.gif # If true, the avatar will be dispalyed in circle. rounded: true # If true, the avatar will be rotated with the cursor. rotated: true 根据发布的博客自动生成首页 根目录执行代码，安装插件 hexo-excerpt1$ npm install hexo-excerpt --save 在主题配置文件中将 excerpt_description 的配置值设置为true，另外在根项目中增加以下内容：123456# 首页excerpt: depth: 2 #按层来算，也就是按代码块来算，截取博文多少层的内容来显示在主页 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true 在线预览 首页阅读更多按钮样式更改 在文件 themes/next/source/css/_common/components/post/post.styl 中添加如下样式：1234567.post-button .btn:hover &#123; color: rgb(255, 255, 255) !important; border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125; 暗黑模式切换 根目录执行代码，安装插件 Hexo NexT Darkmode1$ npm install hexo-next-darkmode --save 在主题配置文件中，首先将NexT默认的暗黑主题设置为 false ： darkmode: false 之后添加如下配置：123456789101112131415darkmode_js: enable: true bottom: &#x27;64px&#x27; # default: &#x27;32px&#x27; right: &#x27;100px&#x27; # default: &#x27;32px&#x27; left: &#x27;unset&#x27; # default: &#x27;unset&#x27; time: &#x27;0.5s&#x27; # default: &#x27;0.3s&#x27; mixColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27; backgroundColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27; buttonColorDark: &#x27;#100f2c&#x27; # default: &#x27;#100f2c&#x27; buttonColorLight: &#x27;#fff&#x27; # default: &#x27;#fff&#x27; isActivated: true # default false saveInCookies: true # default: true label: &#x27;🌓&#x27; # default: &#x27;&#x27; autoMatchOsTheme: true # default: true libUrl: # Set custom library cdn url for Darkmode.js 默认激活暗黑/夜间模式，请始终与 saveInCookies: false、autoMatchOsTheme: false 一起使用 博文加密访问 NexT默认集成加密访问功能，在文件 themes/next/layout/_partials/head/head.swig 中添加如下代码：1234567891011#JavaScript&lt;script&gt; (function()&#123; if(&#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123; if (prompt(&#x27;请输入密码&#x27;) !== &#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123; alert(&#x27;密码错误&#x27;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 之后在需要加密访问的博客中，在头部添加 password 配置即可开启：1password: 123456 默认的加密访问功能，在样式上并不优美，我们可以使用第三方的插件来实现这个功能。根项目安装插件1$ npm install --save hexo-blog-encrypt hexo-blog-encrypt 在根项目的配置文件中增加如下配置12encrypt: enable: true 然后和之前一样，在需要进行加密的博文中，配置相应的 password 属性即可生效。 这种将密码配置到博文中的方式，灵活性不足，如果需要统一配置和更改密码，需要在每个博文中修改一遍。为解决这种问题，插件允许通过指定 tag 来进行加密，并且不同的 tag 可以指定不同的密码。同样在根项目的配置文件中，修改之前的 encrypt 配置1234567891011# 文章加密访问encrypt: enable: true silent: true theme: surge tags: - &#123;name: encrypt, password: 123456&#125; abstract: 博文已加密，请提供密码查看！ message: 输入密码，查看文章 wrong_pass_message: 密码验证失败，请提供正确的密码. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 设置 tags 属性，指定 tag 的 name 和 password 属性，同时在需要进行加密的博文中，设置此 tag 值1tags: [web, ThreeJS, React, encrypt] 增加文章字数统计及阅读时长功能 根项目中安装插件 hexo-symbols-count-time1$ npm install hexo-symbols-count-time --save 在主题配置文件中，搜索 symbols_count_time 配置，NexT默认已经集成此配置，安装插件后重新构建部署即可生效1234symbols_count_time: separated_meta: true item_text_post: true item_text_total: false 代码复制成功反馈 NexT默认已经集成代码复制功能，但是复制成功的反馈默认是禁用的，在主题配置文件中，搜索 codeblock ，将其 show_result 值设置为 true1234567codeblock: highlight_theme: &#x27;night eighties&#x27; copy_button: enable: true # Show text copy result. show_result: false style: flat 开启页面加载进度条 进入到next主题文件目录下执行命令，将插件克隆至主题文件中，文档1$ git clone https://github.com/theme-next/theme-next-pace source/lib/pace 在主题配置文件中，修改 pace 的配置，可以通过修改 theme 以应用不同的进度条主题样式。123456pace: enable: true # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: minimal 博文支持评论 NexT支持多种评论插件，可选值有：changyan 、 disqus 、 disqusjs 、 gitalk | livere | valine，本文使用的是 valine 根据文档提示操作，注册账号、应用，获取到 appId 和 appKey，在主题配置文件中修改配置 设置当前评论模块使用的插件123456comments: # Available values: tabs | buttons style: tabs # Choose a comment system to be displayed by default. # Available values: changyan | disqus | disqusjs | gitalk | livere | valine active: valine valine 配置 appId 和 appKey，其他更多的配置参考官方文档说明1234valine: enable: true appid: xxxx # Your leancloud application appid appkey: xxxx # Your leancloud application appkey 集成网易云音乐 打开网易云网页版，搜索需要添加的歌曲，复制歌曲的外链信息，将其添加到 themes/next/layout/_macro/sidebar.swig 文件中，代码放置位置取决于你想让面板显示在哪个位置1234&lt;!-- 网易云音乐 --&gt;&lt;div id=&quot;music163player&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1901049671&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 标签页美化 在 /themes/next/layout/ 目录下新建文件 tag-color.swig 文件，、填入以下代码1234567891011121314151617181920212223242526272829303132333435&lt;script type=&quot;text/javascript&quot;&gt; var alltags = document.getElementsByClassName(&#x27;tag-cloud-tags&#x27;); var tags = alltags[0].getElementsByTagName(&#x27;a&#x27;); for (var i = tags.length - 1; i &gt;= 0; i--) &#123; var r=Math.floor(Math.random()*75+130); var g=Math.floor(Math.random()*75+100); var b=Math.floor(Math.random()*75+80); tags[i].style.background = &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;; &#125;&lt;/script&gt;&lt;style&gt; .tag-cloud-tags&#123; /*font-family: Helvetica, Tahoma, Arial;*/ /*font-weight: 100;*/ text-align: center; counter-reset: tags; &#125; .tag-cloud-tags a&#123; border-radius: 6px; padding-right: 5px; padding-left: 5px; margin: 8px 5px 0px 0px; &#125; .tag-cloud-tags a:before&#123; content: &quot;&quot;; &#125; .tag-cloud-tags a:hover&#123; box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4); transform: scale(1.1); /*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/ transition-duration: 0.15s; &#125;&lt;/style&gt; 在 /themes/next/layout/page.swig 文件中引入上面新增的文件1234567&#123;%- if page.type === &#x27;tags&#x27; %&#125;&lt;div class=&quot;tag-cloud&quot;&gt; &lt;div class=&quot;tag-cloud-tags&quot; id=&quot;tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 16, max_font: 16, amount: 300, color: true, start_color: &#x27;#FFF&#x27;, end_color: &#x27;#FFF&#x27;&#125;) &#125;&#125; &lt;/div&gt;&lt;/div&gt;&#123;% include &#x27;tag-color.swig&#x27; %&#125; 重新构建部署项目，即可查看效果。在线预览 标签云 使用插件 hexo-tag-cloud1$ npm install hexo-tag-cloud --save 在 themes/next/layout/_macro/sidebar.swig 文件中添加如下代码，重新执行 npm start 可查看效果12345678910111213&lt;!-- 标签云 --&gt;&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&#x27;/js/tagcloud.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&#x27;/js/tagcanvas.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width:100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 在根项目的配置文件中，增加对标签云的属性配置12345678# 标签云tag_cloud: textFont: Trebuchet MS, Helvetica # 字体 textColor: &#x27;#333&#x27; # 字体颜色 textHeight: 25 # 字体大小 outlineColor: &#x27;#E2E1D1&#x27; maxSpeed: 0.3 # 旋转速度 pauseOnSelected: false # 当选中对应标签时，是否停止转动 搜索 在根项目安装插件1$ npm install hexo-algolia --save NexT主题已经默认集成了一部分参数配置，并且在页面的左侧 Slider 区域也有搜索的快捷菜单，在主题配置文件中，搜索 algolia_search，将 enable 值设置为 true，启用该搜索功能。hits.per_page 表示搜索结果分页大小，labels 可以设置搜索匹配提示文本。 需要让搜索功能真正生效，还需要在根项目配置文件中增加 algolia 的账号配置信息12345# searchalgolia: applicationID: &quot;xxx&quot; apiKey: &quot;xxxxx&quot; indexName: &quot;indexName&quot; 配置的信息需要注册 algolia 账号才能获取。可点击 algolia 跳转进行注册。 注册账号后，注册一个应用，应用选择免费版本的。创建应用后在左侧菜单点击 Data Source，选择 Indices，创建一个新的索引，索引名称是博客网站需要配置的一个值，后面会用到。 回到 Overview 总览面板，点击 API Keys，在面板可以看到注册的应用的 application ID。创建新的key，其中的 Indices 选择之前创建的索引，下方的 ACL 权限控制，设置值为：search、addObject、deleteObject、addInde、deleteIndex，其他值默认，然后点击确认创建。 将上述生成的 application ID、apiKey、indexName 填入到配置文件中。 执行以下命令，将网站的博文生成可搜索的静态资源 每次博文有更新，需要部署时，都需要先执行以下命令，再执行构建部署命令，否则更新后的内容，在搜索数据库中是没有更新的。123$ export HEXO_ALGOLIA_INDEXING_KEY=&#x27;0f04bd99beb506cc014d144974134458&#x27;$ export HEXO_ALGOLIA_INDEXING_KEY$ hexo algolia 重新运行项目，点击左侧的搜索，正常情况下，会出现弹框，输入任意内容，即可显示出搜索结果","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/tags/Hexo/"}]},{"title":"Hexo Note - 命令","slug":"Hexo-Note-命令","date":"2022-01-09T07:17:57.000Z","updated":"2022-01-10T06:25:39.399Z","comments":true,"path":"2022/01/09/Hexo-Note-命令/","link":"","permalink":"https://hushaoyu.github.io/2022/01/09/Hexo-Note-%E5%91%BD%E4%BB%A4/","excerpt":"init1$ hexo init projectName","text":"init1$ hexo init projectName 初始化 Hexo 网址项目，在上一节中已经提到过。Hexo Note - 初始化及常用配置 new1$ hexo new [layout] &lt;title&gt; layout: 创建的页面类型。通常有post和page，默认是post，因此在使用时，省略此参数表明创建的是post类型的页面， post：普通的博文，会在首页和归档中列出。 page：独立的页面，不会展示在首页和归档页，如标签页、自定义的404页面等。 其他可选参数： 参数 描述 -p， --path 自定义新博文的路径 -r, --replace 如果存在同名博文，将其替换 -s, --slug 博文的 Slug，作为新博文的文件名和发布后的 URL &ensp;&ensp;默认情况下，Hexo 或根据permalink配置，及文件名称来决定博文生成的路径。如果创建的是独立页面，则使用文件名来在sources目录下生成相应的目录，并在目录下生成index.md文件。 generate1$ hexo generate 生成可直接访问的网站静态文件。其他可选参数： 参数 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件，Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 server1$ hexo server 本地启动服务器。默认情况下，访问网址为：http://localhost:4000/ 其他可选参数： 参数 描述 -p, --port 重新指定端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/tags/Hexo/"}]},{"title":"Hexo Note - 初始化及常用配置","slug":"Hexo-Note-初始化及常用配置","date":"2022-01-09T06:07:29.000Z","updated":"2022-01-10T06:25:39.390Z","comments":true,"path":"2022/01/09/Hexo-Note-初始化及常用配置/","link":"","permalink":"https://hushaoyu.github.io/2022/01/09/Hexo-Note-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","excerpt":"什么是 Hexo ？ &ensp;&ensp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析博文，在几秒内，即可利用靓丽的主题生成静态网页。","text":"什么是 Hexo ？ &ensp;&ensp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析博文，在几秒内，即可利用靓丽的主题生成静态网页。 Markdown站内手册 Markdown官方手册 安装前提安装前，确认机器环境已经安装 Git 和 Node (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)： 12345$ git --versiongit version 2.31.1.windows.1$ node -vv14.13.0 安装 Hexo&ensp;&ensp;全局安装hexo cli工具 1$ npm install -g hexo-cli 搭建网站初始化博客项目目录，并安装依赖12$ hexo init projectName$ cd projectName &amp;&amp; npm install &ensp;&ensp;构建后可以看到目录的基本结构，其中_.config.yml为网站的配置文件；source为资源文件，比如后续需要新建的博文，就是在这个目录下生成的；themes是主题文件夹，Hexo将根据这个目录下的资源配置，来渲染网站，生成页面。 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 配置网站&ensp;&ensp;博客网站的网站标题、描述，以及网站的归属等信息设置 参数 描述 title 网站标题 subtitle 网站副标题 description 描述，主要用于SEO，建议准确描述网站内容，可使用关键字 keywords 关键字 author 网站作者 language 网站所使用的语言，可根据使用的主题提供的语言选项来进行设置，如zh-CN timezone 网站时区，中国大陆用户可以设置 Asia/Shanghai，具体可参见 时区列表 网址&ensp;&ensp;通常用于设置网站网址即博文的永久链接格式 参数 描述 默认值 url 网址，协议需要指定，如 http:// 或者 https:// permalink 博文的永久链接格式，具体格式可查看 永久链接格式 pretty_urls 改写 permalink 的值来美化 URL pretty_urls.trailing_index 是否在永久链接中保留尾部的 index.html，设置为 false 时去除 pretty_urls.trailing_html 是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效) true 其他更详细的配置说明，可查看 官网说明","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/tags/Hexo/"}]},{"title":"Markdown using document","slug":"Markdown-using-document","date":"2022-01-05T05:35:07.000Z","updated":"2022-01-10T06:25:39.378Z","comments":true,"path":"2022/01/05/Markdown-using-document/","link":"","permalink":"https://hushaoyu.github.io/2022/01/05/Markdown-using-document/","excerpt":"基本语法标题","text":"基本语法标题1、一个 ‘#’ 表示一级标题，两个表示二级标题，依此类推，对应 h1 ~ h6二级标题三级标题四级标题五级标题六级标题 段落1、直接使用空白行来标记行分割content1 content2 换行1、在内容末尾使用br，可创建换行例子：在内容末尾使用br，可创&lt;br /&gt;建换行例子：在内容末尾使用br，可创建换行 强调1、在需要强调的内容前后使用两个星号进行标记这段文字中，地名是需要强调的，如：**北京**是个美丽的城市，**杭州**也是这段文字中，地名是需要强调的，如：北京是个美丽的城市，杭州也是 引用1、块引用：使用 ‘&gt;’ 符号，多行引用，使用空 ‘&gt;’ 隔开 import import 2、嵌套引用：后面多一个 ‘&gt;’，表示被嵌套，如 ‘&gt;&gt;’ first second 3、包含其他Markdown语法的引用 content list Everything is going ware; 列表1、有序列表：使用数字加英文句号进行标记，英文句号需要与后续内容间隔一个空格语法才生效 第一行 第二行 2、无序列表：使用连字符 ‘-‘。子级列表，使用两个空格递进表示层级。 第一行 第二行 子行 代码1、代码块使用反引号包裹 ``这里面的是代码块内容，里层再次使用反引号，可识别Markdown语法，如``&lt;br /&gt;`` 标签就是被识别的效果 分割线1、分割线使用三个连续的星号（最佳实践：在星号前后使用空白行） 链接1、链接文本放在中括号内，链接地址放在紧跟其后的小括号内，小括号内第一个值为超链接，第二个使用双引号包裹的为title[这是一个链接](https://www.baidu.com &quot;这是一个百度地址&quot;)这是一个链接 2、带格式化的链接这是一个 **[百度](https://www.baidu.com &quot;这是一个百度地址&quot;)** 链接这是一个 百度 链接 图片1、与使用超链接类似，只是在最前面加了感叹号，中括号内的为图片的替代文本，即alt属性![这是图片](/assets/img/philly-magic-garden.jpg &quot;Magic Gardens&quot;) 2、带超链接的图片：先使用中括号包裹图片语法内容，再在中括号后面加一个小括号，放入超链接地址[![这是图片](https://upload.wikimedia.org/wikipedia/commons/a/a6/Future_Splash_Animator_icon.png &quot;Animate&quot;)](https://en.wikipedia.org/wiki/File:Future_Splash_Animator_icon.png) 转义符 内嵌 HTML 标签1、自定义样式使用样式自定义&lt;span style=&quot;color: rgb(255,3,255);margin: 0 5px;&quot;&gt;标签&lt;/span&gt;样式 使用样式自定义标签样式 扩展语法表格1、基本用法：使用管道符分割列，使用三个或多个连字符创建列标题| syntax | description | | --- | --- || header | title || name | value | | name | value | syntax description header title name value name value 2、内容对齐：在连字符前后加冒号，左边冒号表示左对齐，右边表示右对齐，两侧都有表示居中| syntax | description | other | | :--- | :---: | ---: || 1 | title | 1 || 1 | value | 1 | | 1 | value | 1 | syntax description other 1 title 1 1 value 1 1 value 1 围栏代码块1、使用三个反引号```包裹表示围栏代码块，如果只用单个反引号包裹，只会形成一行12345&#123; &quot;key&quot;: 1, &quot;name&quot;: &quot;test&quot;, &quot;value&quot;: 2&#125; &#123; &quot;key&quot;: 1, &quot;name&quot;: &quot;test&quot;, &quot;value&quot;: 2 &#125; 2、语法高亮：在第一个三个反引号后面，加上高亮所使用的语法，取值有：json、bash、javascript等 json：12345&#123; &quot;key&quot;: 1, &quot;name&quot;: &quot;test&quot;, &quot;value&quot;: 2&#125; bash：1$ midkr test javascript：12const a = &#x27;test&#x27;;console.log(a); 脚注1、方括号内，使用上标符号接其他标识符这里面的内容包含[^1]脚注。 [^1]: this is a 标题ID和锚点1、标题内容使用内嵌html标签的形式提供id### &lt;span id=&quot;extend-table&quot;&gt;表格&lt;/span&gt; 2、使用中括号包含描点文本内容，后接小括号提供id[跳至表格](#extend-table)跳至表格 删除线1、使用双波浪号~~~~内容删除~~内容删除 任务列表语法1、使用 -/*/+ 和方括号表示，方括号内输入x表示任务已完成。方括号前后均需空格，空复选框也需要空格123- [x] 起床* [ ] 洗漱+ [ ] 吃早餐 起床 洗漱 吃早餐 使用emoji表情12- 🏜️ 第一次使用表情- 🎄 圣诞树 其他中文段落缩进两个字符,使用&amp;ensp;；&amp;ensp;&amp;ensp;这是一段缩进两个字符的文本&ensp;&ensp;这是一段缩进两个字符的文本 站内博文间跳转 相对路径 在站点的根配置文件中，permalink参数指定了博文的生成格式：permalink: :year/:month/:day/:title/，因此在是使用相对路径时，需要根据日期递归到根目录再寻址到需要跳转的博文路径：12345 [Markdown站内手册](../../../../2022/01/05/Markdown-using-document)```- 绝对路径 - 同样根据博文的生成格式，将博文从根路径开始，将绝对路径表示出来： ```bash [Markdown站内手册](/2022/01/05/Markdown-using-document) post_link 待研究","categories":[{"name":"handbook","slug":"handbook","permalink":"https://hushaoyu.github.io/categories/handbook/"},{"name":"Markdown","slug":"handbook/Markdown","permalink":"https://hushaoyu.github.io/categories/handbook/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://hushaoyu.github.io/tags/Markdown/"},{"name":"handbook","slug":"handbook","permalink":"https://hushaoyu.github.io/tags/handbook/"}]},{"title":"There.js入门系列之React中使用Three.js","slug":"There-js入门系列之React中使用Three-js","date":"2022-01-05T05:27:18.000Z","updated":"2022-01-07T03:21:35.579Z","comments":true,"path":"2022/01/05/There-js入门系列之React中使用Three-js/","link":"","permalink":"https://hushaoyu.github.io/2022/01/05/There-js%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8BReact%E4%B8%AD%E4%BD%BF%E7%94%A8Three-js/","excerpt":"博文已加密，请提供密码查看！","text":"4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b0f41eb1e0ff1190f7511b2f172bf61b91eebc2f7ad92bd458a943c3f388d15fd6ffb2ab5dcdd5ca5be7a53be65b3149bb68de244f810ed966192b82228cdc362f088736edaaebe931c47c95f67ac4e50728df6f82eadb0a90e5cfe6620d8a8a6eb19dbbeee5ff4bee397f5e2a06331e852650d318beb5578cbbdda3c37d25f099a3b7f7493d41b725f14299d4e561a775c7cebf554da7b204f69b22c85a4f4d8ebc9b3826ec2750cc9e1ea4ad32fad91d2ebc6ab087580e18304105159ef6f69a27d67bdefafb0d2f7628aa0422745e7726a829b9b2d293c9a0c0832bbc6f5e881ceb4e79c6a082d5afd0578a69d56fc0d8a964539a0f1771a5f25c207c236714cb234097a0e3e7232895ac7cf6342358acd594c34693d181d93ad985f5a6651087a80c93c4a7bbb8f3348ed6cdc6d175 输入密码，查看文章","categories":[{"name":"web","slug":"web","permalink":"https://hushaoyu.github.io/categories/web/"},{"name":"ThreeJS","slug":"web/ThreeJS","permalink":"https://hushaoyu.github.io/categories/web/ThreeJS/"}],"tags":[{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/tags/React/"},{"name":"web","slug":"web","permalink":"https://hushaoyu.github.io/tags/web/"},{"name":"ThreeJS","slug":"ThreeJS","permalink":"https://hushaoyu.github.io/tags/ThreeJS/"},{"name":"encrypt","slug":"encrypt","permalink":"https://hushaoyu.github.io/tags/encrypt/"}]}],"categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://hushaoyu.github.io/categories/TypeScript/"},{"name":"React Props","slug":"TypeScript/React-Props","permalink":"https://hushaoyu.github.io/categories/TypeScript/React-Props/"},{"name":"工具","slug":"工具","permalink":"https://hushaoyu.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"ThreeJs","slug":"ThreeJs","permalink":"https://hushaoyu.github.io/categories/ThreeJs/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/categories/Hexo/"},{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/categories/React/"},{"name":"插件","slug":"React/插件","permalink":"https://hushaoyu.github.io/categories/React/%E6%8F%92%E4%BB%B6/"},{"name":"Echarts","slug":"Echarts","permalink":"https://hushaoyu.github.io/categories/Echarts/"},{"name":"微信小程序，开发笔记","slug":"微信小程序，开发笔记","permalink":"https://hushaoyu.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"name":"nodeppt","slug":"nodeppt","permalink":"https://hushaoyu.github.io/categories/nodeppt/"},{"name":"PPT","slug":"PPT","permalink":"https://hushaoyu.github.io/categories/PPT/"},{"name":"nodeppt","slug":"PPT/nodeppt","permalink":"https://hushaoyu.github.io/categories/PPT/nodeppt/"},{"name":"create-react-app","slug":"React/create-react-app","permalink":"https://hushaoyu.github.io/categories/React/create-react-app/"},{"name":"webpack","slug":"webpack","permalink":"https://hushaoyu.github.io/categories/webpack/"},{"name":"CSS","slug":"CSS","permalink":"https://hushaoyu.github.io/categories/CSS/"},{"name":"handbook","slug":"handbook","permalink":"https://hushaoyu.github.io/categories/handbook/"},{"name":"Markdown","slug":"handbook/Markdown","permalink":"https://hushaoyu.github.io/categories/handbook/Markdown/"},{"name":"web","slug":"web","permalink":"https://hushaoyu.github.io/categories/web/"},{"name":"ThreeJS","slug":"web/ThreeJS","permalink":"https://hushaoyu.github.io/categories/web/ThreeJS/"}],"tags":[{"name":"React","slug":"React","permalink":"https://hushaoyu.github.io/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://hushaoyu.github.io/tags/TypeScript/"},{"name":"工具","slug":"工具","permalink":"https://hushaoyu.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"ThreeJs","slug":"ThreeJs","permalink":"https://hushaoyu.github.io/tags/ThreeJs/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hushaoyu.github.io/tags/Hexo/"},{"name":"插件","slug":"插件","permalink":"https://hushaoyu.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"react-codemirror2","slug":"react-codemirror2","permalink":"https://hushaoyu.github.io/tags/react-codemirror2/"},{"name":"Echarts","slug":"Echarts","permalink":"https://hushaoyu.github.io/tags/Echarts/"},{"name":"开发笔记","slug":"开发笔记","permalink":"https://hushaoyu.github.io/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"name":"微信小程序，开发笔记","slug":"微信小程序，开发笔记","permalink":"https://hushaoyu.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"name":"nodeppt","slug":"nodeppt","permalink":"https://hushaoyu.github.io/tags/nodeppt/"},{"name":"PPT","slug":"PPT","permalink":"https://hushaoyu.github.io/tags/PPT/"},{"name":"框架搭建","slug":"框架搭建","permalink":"https://hushaoyu.github.io/tags/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"},{"name":"creat-react-app","slug":"creat-react-app","permalink":"https://hushaoyu.github.io/tags/creat-react-app/"},{"name":"webpack","slug":"webpack","permalink":"https://hushaoyu.github.io/tags/webpack/"},{"name":"CSS","slug":"CSS","permalink":"https://hushaoyu.github.io/tags/CSS/"},{"name":"开发技巧","slug":"开发技巧","permalink":"https://hushaoyu.github.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"Markdown","slug":"Markdown","permalink":"https://hushaoyu.github.io/tags/Markdown/"},{"name":"handbook","slug":"handbook","permalink":"https://hushaoyu.github.io/tags/handbook/"},{"name":"web","slug":"web","permalink":"https://hushaoyu.github.io/tags/web/"},{"name":"ThreeJS","slug":"ThreeJS","permalink":"https://hushaoyu.github.io/tags/ThreeJS/"},{"name":"encrypt","slug":"encrypt","permalink":"https://hushaoyu.github.io/tags/encrypt/"}]}